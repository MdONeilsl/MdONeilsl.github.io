{
  "name": "efficiency",
  "id": "efficiency",
  "description": "Overview of techniques to optimize LSL scripts for execution speed and memory efficiency",
  "details": {
    "purpose": "To guide AI in writing LSL scripts that execute quickly while respecting memory constraints, prioritizing execution speed over memory savings unless memory is critically limited",
    "efficiency_mechanics": {
      "description": "LSL scripts run in a shared Second Life VM with a 64 KB compiled bytecode limit (Mono) and variable execution time limits based on server load. Execution speed is the primary optimization goal to minimize lag and enhance user experience. Memory efficiency is secondary but critical to avoid exceeding the 64 KB limit, which causes compilation failure. Variables consume fixed memory (e.g., integer: 16 bytes globally, 7 bytes in default state; string: 18 bytes + 2 per character; list: 8 bytes + data in Mono). Inline code reduces runtime by eliminating function call overhead but increases bytecode size, while functions save memory but add execution time. Optimization techniques focus on speeding execution through pre-calculations, efficient types, and minimal event triggers, with memory-saving strategies applied only when they do not compromise speed",
      "recommendation": "Prioritize execution speed with inline code, pre-calculated constants, and efficient types; monitor memory using llGetUsedMemory or in-world tools to stay within 64 KB"
    },
    "optimization_techniques": [
      {
        "name": "inline_code",
        "description": "Use inline code in events for small to medium tasks to eliminate function call overhead, even if it increases bytecode size"
      },
      {
        "name": "pre_calculated_constants",
        "description": "Pre-calculate constant values (e.g., float HALF_PI = 1.57079632679) to avoid repeated computations in loops or events"
      },
      {
        "name": "efficient_types",
        "description": "Use integer for counters and indices instead of float for faster arithmetic; avoid lists for simple data to reduce memory and access time"
      },
      {
        "name": "consolidated_events",
        "description": "Minimize event handlers by consolidating logic in fewer events (e.g., handle multiple conditions in one touch_start)"
      },
      {
        "name": "timer_delays",
        "description": "Use llSetTimer for non-blocking delays instead of llSleep, which blocks execution and increases lag"
      },
      {
        "name": "optimized_conditionals",
        "description": "Simplify conditionals (e.g., if (x) instead of if (x == 1)) to reduce evaluation time"
      },
      {
        "name": "bitwise_operations",
        "description": "Use bitwise operations for flag checks (e.g., if (flags & PERMISSION_CONTROL_CAMERA)) to combine multiple conditions efficiently"
      },
      {
        "name": "string_reuse",
        "description": "Store reusable strings in global variables or use interned strings (4 bytes in Mono) to avoid recreating them, reducing memory allocation and execution time"
      },
      {
        "name": "minimize_script_count",
        "description": "Use fewer scripts by consolidating logic, e.g., using llDetectedLinkNumber for multiple buttons instead of per-prim scripts"
      },
      {
        "name": "avoid_short_timers",
        "description": "Set timers to at least 5 seconds to reduce performance overhead from frequent triggers"
      },
      {
        "name": "minimize_listen_events",
        "description": "Avoid listen events on channel 0, which is particularly inefficient due to high traffic"
      },
      {
        "name": "reduce_texture_changes",
        "description": "Minimize texture changes to avoid forcing downloads on other users, improving client-side performance"
      },
      {
        "name": "use_efficient_rotations",
        "description": "Prefer llRotLookAt with omega over server or physical rotations for smoother and faster performance"
      },
      {
        "name": "remove_unnecessary_event_handlers",
        "description": "Eliminate unused event handlers (e.g., empty touch or collision events) to reduce overhead"
      },
      {
        "name": "limit_communication",
        "description": "Avoid excessive email or IM usage to maintain efficiency and reduce server load"
      },
      {
        "name": "use_efficient_algorithms",
        "description": "Avoid linear searches or other inefficient algorithms to speed up data processing"
      },
      {
        "name": "avoid_busy_polling",
        "description": "Use timers or events instead of constant polling loops to reduce CPU usage"
      },
      {
        "name": "micro_optimizations",
        "description": "Use ++a over a++ for slightly faster execution, though impact may be minimal in Mono"
      },
      {
        "name": "efficient_communication",
        "description": "Use llRegionSay for faster region-local messaging compared to llSay or llShout"
      },
      {
        "name": "link_functions_for_prim_changes",
        "description": "Use llSetLinkAlpha, llSetLinkColor, etc., for managing child prims efficiently without iterating over links"
      },
      {
        "name": "minimize_memory_usage",
        "description": "Declare variables in the default state (e.g., integer: 7 bytes vs. 16 globally), use interned strings (4 bytes), avoid lists and typecasting, and minimize function declarations to save memory without slowing execution"
      }
    ],
    "best_practices": [
      "Prioritize execution speed with inline code and pre-calculations unless memory usage nears 64 KB",
      "Use integer for counters and loops to speed up arithmetic operations",
      "Avoid llSleep; use llSetTimer for non-blocking delays to maintain responsiveness",
      "Consolidate logic in fewer event handlers to reduce event trigger overhead",
      "Use bitwise operations for efficient flag checks in permission or status logic",
      "Store frequently used strings in global variables or use interned strings to minimize reallocation",
      "Avoid lists for simple data; use individual variables for faster access and lower memory use",
      "Declare variables in the default state to save memory (e.g., integer: 7 bytes vs. 16 globally)",
      "Use llSetMemoryLimit to reduce memory footprint if necessary, without compromising speed",
      "Test scripts in-world to measure lag and memory usage, adjusting for performance",
      "Monitor bytecode size using llGetUsedMemory or in-world tools to stay within limits"
    ],
    "examples": [
      {
        "description": "Inline code for a greeting",
        "code": "default\n{\n    touch_start(integer num_detected)\n    {\n        llSay(0, \"Hello, \" + llDetectedName(0));\n    }\n}",
        "context": "Inlines llSay and llDetectedName in touch_start to avoid function call overhead, prioritizing speed over memory"
      },
      {
        "description": "Pre-calculated constant for rotation",
        "code": "float HALF_PI = 1.57079632679;\n\ndefault\n{\n    state_entry()\n    {\n        integer i;\n        for (i = 0; i < 4; ++i)\n        {\n            float angle = i * HALF_PI;\n            llSay(0, \"Rotation angle: \" + (string)angle);\n        }\n    }\n}",
        "context": "Uses pre-calculated HALF_PI to avoid computing PI / 2 in each loop iteration, speeding up execution"
      },
      {
        "description": "Timer-based delay with string reuse",
        "code": "string MESSAGE = \"Checking position\";\n\ndefault\n{\n    state_entry()\n    {\n        llSetTimer(5.0, TRUE);\n    }\n    timer()\n    {\n        llSay(0, MESSAGE + \": \" + (string)llGetPos());\n    }\n}",
        "context": "Uses llSetTimer for a non-blocking 5-second delay and reuses a global string, avoiding llSleep and string reallocation"
      },
      {
        "description": "Bitwise flag check for permissions",
        "code": "default\n{\n    run_time_permissions(integer perm)\n    {\n        if (perm & PERMISSION_CONTROL_CAMERA)\n        {\n            llSay(0, \"Camera control granted\");\n        }\n    }\n}",
        "context": "Uses bitwise operation to check permission flags efficiently, reducing conditional complexity"
      }
    ],
    "references": [
      {
        "url": "https://wiki.secondlife.com/wiki/LSL_Script_Efficiency",
        "title": "LSL Wiki: LSL Script Efficiency"
      },
      {
        "url": "https://wiki.secondlife.com/wiki/LSL_Script_Memory",
        "title": "LSL Wiki: LSL Script Memory"
      },
      {
        "url": "https://wiki.secondlife.com/wiki/LSL_Hacks",
        "title": "LSL Wiki: LSL Hacks"
      },
      {
        "url": "https://wiki.secondlife.com/wiki/User:Omei_Qunhua",
        "title": "LSL Wiki: User:Omei_Qunhua"
      },
      {
        "url": "https://wiki.secondlife.com/wiki/LSL_Portal",
        "title": "LSL Wiki: LSL Portal"
      }
    ]
  }
}

