{
  "name": "flow_control",
  "id": "flow_control",
  "description": "Overview of LSL flow control constructs, which manage the execution order of script logic using conditional statements, loops, jumps, and state transitions",
  "details": {
    "purpose": "To guide AI in using LSL flow control constructs to manage script execution, ensuring correct conditional logic, looping, and state transitions while adhering to LSLâ€™s syntax and constraints",
    "conditional_statements": {
      "description": "Conditional statements in LSL use if, else if, and else to control execution based on boolean conditions. LSL does not support a ternary operator (e.g., condition ? value1 : value2); use if-else statements or simple conditionals for conditional assignments. Conditions must evaluate to a boolean (e.g., integer x = 5; if (x > 3) {...})",
      "rules": [
        "Use if (condition) { ... } for single conditions.",
        "Use else if (condition) { ... } and else { ... } for multiple conditions.",
        "Conditions must be boolean; non-boolean values (e.g., if (5)) cause compilation errors.",
        "Do not use ternary operators (e.g., x = condition ? value1 : value2); they are not supported in LSL.",
        "Simplify conditionals for speed (e.g., if (x) instead of if (x == 1)), per lsl_efficiency.json."
      ],
      "examples": [
        {
          "description": "Conditional assignment using if-else",
          "code": "default\n{\n    state_entry()\n    {\n        integer x = 5;\n        string message;\n        if (x > 3)\n        {\n            message = \"High\";\n        }\n        else\n        {\n            message = \"Low\";\n        }\n        llSay(0, message);\n    }\n}",
          "context": "Assigns a string based on a condition using if-else, avoiding ternary operator, per lsl_flow_control.json"
        },
        {
          "description": "Simple conditional check",
          "code": "default\n{\n    touch_start(integer num_detected)\n    {\n        if (llDetectedKey(0) == llGetOwner())\n        {\n            llSay(0, \"Owner touched\");\n        }\n    }\n}",
          "context": "Checks a condition without else, per lsl_flow_control.json"
        }
      ]
    },
    "loops": {
      "description": "Loops in LSL include for, while, and do-while to repeat code execution. Use integer counters for speed, per lsl_efficiency.json",
      "rules": [
        "For loops: for (init; condition; update) { ... }.",
        "While loops: while (condition) { ... }.",
        "Do-while loops: do { ... } while (condition);.",
        "Ensure conditions eventually terminate to avoid infinite loops.",
        "Use integer for loop counters to optimize speed, per lsl_efficiency.json."
      ],
      "examples": [
        {
          "description": "For loop with integer counter",
          "code": "default\n{\n    state_entry()\n    {\n        integer i;\n        for (i = 0; i < 5; ++i)\n        {\n            llSay(0, (string)i);\n        }\n    }\n}",
          "context": "Uses integer counter for speed, per lsl_efficiency.json"
        }
      ]
    },
    "jumps": {
      "description": "Jumps in LSL use @label; and jump label; to redirect execution within the same scope. Use sparingly due to readability concerns",
      "rules": [
        "Define labels with @label;.",
        "Use jump label; to redirect to a label.",
        "Jumps must be within the same scope (e.g., event or function).",
        "Avoid overuse; prefer loops or conditionals for clarity."
      ],
      "examples": [
        {
          "description": "Jump to skip code",
          "code": "default\n{\n    state_entry()\n    {\n        integer x = 0;\n        if (x == 0) jump end;\n        llSay(0, \"Skipped\");\n        @end;\n        llSay(0, \"Done\");\n    }\n}",
          "context": "Uses jump to skip a statement, per lsl_flow_control.json"
        }
      ]
    },
    "state_transitions": {
      "description": "State transitions in LSL use state new_state; to switch between states defined in the script. Each state has its own event handlers",
      "rules": [
        "Use state new_state; to transition to a defined state.",
        "States are defined with state name { ... }.",
        "State transitions reset local variables but preserve global variables.",
        "Ensure states are defined before transitioning."
      ],
      "examples": [
        {
          "description": "State transition",
          "code": "default\n{\n    touch_start(integer num_detected)\n    {\n        state active;\n    }\n}\nstate active\n{\n    state_entry()\n    {\n        llSay(0, \"Active state\");\n    }\n}",
          "context": "Transitions from default to active state, per lsl_flow_control.json"
        }
      ]
    },
    "best_practices": [
      "Use if-else for conditional logic; avoid non-existent constructs like ternary operators.",
      "Simplify conditions (e.g., if (x) instead of if (x == TRUE)) for speed, per lsl_efficiency.json.",
      "Use integer counters in loops to optimize performance, per lsl_efficiency.json.",
      "Avoid infinite loops by ensuring termination conditions.",
      "Use jumps sparingly; prefer structured loops or conditionals for readability.",
      "Ensure state transitions target defined states to avoid compilation errors.",
      "Test flow control logic in-world to verify behavior, per lsl_efficiency.json."
    ]
  }
}